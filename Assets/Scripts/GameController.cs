using UnityEngine; using System.Collections; using System.Collections.Generic; using UnityEngine.UI; using UnityEngine.SceneManagement; using System; using System.Runtime.Serialization.Formatters.Binary; using UnityStandardAssets.Characters.FirstPerson; using System.IO; using System.Linq;  public class GameController : MonoBehaviour {     /// <summary>     /// The GameController is a singleton script will control the game flow between scenes,      /// and centralise everything so all main processes branch from here.     /// This is a simplified, general purpose version for creating different behavioural experiments in Unity.     /// Author: Hannah Sheahan, sheahan.hannah@gmail.com     /// Date: 30 Oct 2018     /// Notes: N/A     /// Issues: N/A     ///      /// </summary>      // Persistent controllers for data management and gameplay     private DataController dataController;     public static GameController control;      // Game data     private GameObject Player;     private GameData currentGameData;     private string filepath;      // Start-of-trial data     private TrialData currentTrialData;     private string currentMapName;     private string currentSceneName;     private string nextScene;      // Within-trial data that changes with timeframe     private bool choiceMade = false;     public string whichChoiceMade;     public bool correctChoiceMade = false;     private string trialAnswer;      // Audio clips     public AudioClip choiceMadeSound;     public AudioClip goCueSound;     public AudioClip errorSound;
    public AudioClip correctSound;     public AudioClip fallSound;     public AudioClip openBoxSound;     private AudioSource source;      // Messages to the screen     private string displayMessage = "noMessage";     public string textMessage = "";     public bool displayCue;     public string rewardType;     public bool rewardVisible;     public int trialScore = 0;     public int totalScore = 0;     public int nextScore;     public bool flashTotalScore = false;     public bool scoreUpdated = false;     public bool pauseClock = false;     public bool congratulated = false;     public bool audioFeedbackSounded = false;     public bool flashColourFeedback = false;      // Timer variables     private Timer experimentTimer;     private Timer stateTimer;     private Timer movementTimer;     private Timer restbreakTimer;     private Timer getReadyTimer;     public  Timer messageTimer;     public float responseTime;     public float totalExperimentTime;     public float currentTickingTrialTime;           // current trial time for measuring RX. Measured from 'go' cue     public bool  displayTimeLeft;      public float maxResponseTime;       private float preDisplayCueTime;     private float goCueDelay;     private float displayCueTime;     private float finalGoalHitPauseTime;     public  float minDwellAtReward;      public float displayMessageTime;      public float errorDwellTime;     public float restbreakDuration;     public float elapsedRestbreakTime;     public float getReadyTime;     public float getReadyDuration;     public float pausePriorFeedbackTime;     private float feedbackFlashDuration;      public float dataRecordFrequency;           // NOTE: this frequency is referred to in TrackingScript.cs for player data and here for state data     public float timeRemaining;      // Error flags     public bool FLAG_trialError;     public bool FLAG_trialTimeout;     public bool FLAG_fullScreenModeError;      // Game-play state machine states     public const int STATE_STARTSCREEN = 0;     public const int STATE_SETUP       = 1;     public const int STATE_STARTTRIAL  = 2;     public const int STATE_CUEAPPEAR   = 3;     public const int STATE_DELAY       = 4;     public const int STATE_GO          = 5;     public const int STATE_MOVING      = 6;     public const int STATE_CHOICEMADE  = 7;     public const int STATE_FINISH      = 8;     public const int STATE_NEXTTRIAL   = 9;     public const int STATE_INTERTRIAL  = 10;     public const int STATE_TIMEOUT     = 11;     public const int STATE_ERROR       = 12;     public const int STATE_FEEDBACK    = 13;     public const int STATE_REST        = 14;     public const int STATE_GETREADY    = 15;     public const int STATE_PAUSE       = 16;     public const int STATE_EXIT        = 17;     public const int STATE_MAX         = 18;      private string[] stateText = new string[] { "StartScreen","Setup","StartTrial","CueAppear","Delay","Go","Moving","ChoiceMade", "Finish","NextTrial","InterTrial","Timeout","Error","Feedback","Rest","GetReady","Pause","Exit","Max" };     public int State;     public int previousState;     // Note that this currently is not thoroughly used - currently only used for transitioning back from the STATE_HALLFREEZE to the previous gameplay     public List<string> stateTransitions = new List<string>();   // recorded state transitions (in sync with the player data)      private bool gameStarted = false;      // ********************************************************************** //      void Awake ()           // Awake() executes once before anything else     {         // Make GameController a singleton         if (control == null)   // if control doesn't exist, make it         {             DontDestroyOnLoad(gameObject);             control = this;         }         else if (control != this) // if control does exist, destroy it         {             Destroy(gameObject);         }     }      // ********************************************************************** //      private void Start()     // Start() executes once when object is created     {         dataController = FindObjectOfType<DataController>(); //usually be careful with 'Find' but in this case should be ok. Ok this fetches the instance of DataController, dataController.         source = GetComponent<AudioSource>();          // Trial invariant data         filepath = dataController.filePath;   //this works because we actually have an instance of dataController         Debug.Log("File path: " + filepath);         dataRecordFrequency = dataController.GetRecordFrequency();         restbreakDuration = dataController.GetRestBreakDuration();         getReadyDuration = dataController.GetGetReadyDuration();          // Initialise the timers         experimentTimer = new Timer();         movementTimer = new Timer();         messageTimer = new Timer();         restbreakTimer = new Timer();         getReadyTimer = new Timer();          // Initialise FSM State         State = STATE_STARTSCREEN;         previousState = STATE_STARTSCREEN;         stateTimer = new Timer();         stateTimer.Reset();         stateTransitions.Clear();          // Ensure cue images are off         displayCue = false;         rewardVisible = false;          StartExperiment();        }      // ********************************************************************** //      private void Update()     // Update() executes once per frame     {         UpdateText();         CheckFullScreen();          if (!pauseClock)         {             currentTickingTrialTime = movementTimer.ElapsedSeconds();         }          switch (State)         {              case STATE_STARTSCREEN:                 // Note: we chill out here in this state until all the starting info pages are done                 if (gameStarted)                 {                     StateNext(STATE_SETUP);                 }                 break;              case STATE_SETUP:                  switch (TrialSetup())                 {                     case "StartTrial":                         // ensure the reward is hidden from sight                         rewardVisible = false;                         StateNext(STATE_STARTTRIAL);                          break;                     case "Menus":                         //   ***HRS to remove: this case should never have to do anything                         break;                      case "GetReady":                         getReadyTimer.Reset();                         StateNext(STATE_GETREADY);                         break;                      case "RestBreak":                         restbreakTimer.Reset();                         StateNext(STATE_REST);                         break;                      case "Exit":                         totalExperimentTime = experimentTimer.ElapsedSeconds();                         Cursor.lockState = CursorLockMode.None;                         StateNext(STATE_EXIT);                         break;                  }                 break;              case STATE_STARTTRIAL:                  StartRecording();                      // Wait until the goal/target cue appears (will take a TR here)                 if (stateTimer.ElapsedSeconds() >= preDisplayCueTime)                 {
                    Cursor.lockState = CursorLockMode.Locked;                      StateNext(STATE_CUEAPPEAR);                 }                 break;               case STATE_CUEAPPEAR:                 // display the reward type cue                 displayCue = true;                 if (stateTimer.ElapsedSeconds() > displayCueTime)                 {                     displayCue = false;                     choiceMade = false;                     StateNext(STATE_DELAY);                     break;                 }                 break;              case STATE_DELAY:                 // Wait for the go audio cue (will take a TR here)                  if (stateTimer.ElapsedSeconds() >= goCueDelay)                 {                     source.PlayOneShot(goCueSound, 1F);                     rewardVisible = true;     // make the reward itself appear in the environment                     StateNext(STATE_GO);                 }                 break;              case STATE_GO:                  // Enable the controller                 Cursor.lockState = CursorLockMode.None;                  // Make a 'beep' go sound and start the trial timer                 movementTimer.Reset();                 displayTimeLeft = true;   // make the trial time countdown visible                 StateNext(STATE_MOVING);                 break;              case STATE_MOVING:                  if (movementTimer.ElapsedSeconds() > maxResponseTime) // maximum response time                 {                     StateNext(STATE_TIMEOUT);                 }                  if (choiceMade)                 {                     source.PlayOneShot(choiceMadeSound, 1F);                     responseTime = movementTimer.ElapsedSeconds();                     StateNext(STATE_CHOICEMADE);                 }                 break;              case STATE_CHOICEMADE:

                Cursor.lockState = CursorLockMode.Locked;  // disable controller                 displayTimeLeft = false;                   // freeze the visible countdown 
                // its nice to wait a moment or so before providing feedback
                if (stateTimer.ElapsedSeconds() > pausePriorFeedbackTime)                  {                     StateNext(STATE_FEEDBACK);                 }                  break; 

            case STATE_FEEDBACK:

                // display appropriate feedback colour highlight and feedback sound                 if ( !audioFeedbackSounded )                  {
                    // determine whether the choice was correct or not
                    if (whichChoiceMade == trialAnswer)                     {                         Debug.Log("Choice correct!");                         correctChoiceMade = true;                     }                     else                     {                         Debug.Log("Choice incorrect!");                         correctChoiceMade = false;                     } 
                    flashColourFeedback = true;              // enable the colours feedback on the buttons                     if (correctChoiceMade)                      {                         source.PlayOneShot(correctSound, 1F);
                        Debug.Log("Green colour and nice sound will happen now");                     }                     else   // incorrect choice                     {
                        source.PlayOneShot(errorSound, 1F);                         Debug.Log("Red colour and error sound will happen now");
                    }                     audioFeedbackSounded = true;                 }

                // update the total score and flash feedback it on the screen
                if (stateTimer.ElapsedSeconds() > feedbackFlashDuration)
                {                     flashColourFeedback = false;            // turn the colour button feedback off so that it 'flashes'
                    UpdateScore();                          
                }
                if (stateTimer.ElapsedSeconds() > finalGoalHitPauseTime)
                {
                    flashTotalScore = false;
                    StateNext(STATE_FINISH);
                }

                break;              case STATE_FINISH:                  // stop recording the state transitions for this trial                 CancelInvoke("RecordFSMState");                  // end the trial, save the data                 NextScene();                 StateNext(STATE_SETUP);                 break;              case STATE_TIMEOUT:                  FLAG_trialTimeout = true;                 displayMessage = "timeoutMessage";                 Debug.Log("Trial timed out: (after " + movementTimer.ElapsedSeconds() + " sec)");                  StateNext(STATE_ERROR);                 break;              case STATE_ERROR:                 // Handle error trials by continuing to record data on the same trial ***HRS                 if (FLAG_trialError == false)                 {                     source.PlayOneShot(errorSound, 1F);                     displayMessage = "restartTrialMessage";                     UpdateScore();   // take -20 points off total score                 }                 FLAG_trialError = true;                  responseTime = movementTimer.ElapsedSeconds();                  // Wait a little while in the error state to display the error message                 if (stateTimer.ElapsedSeconds() > errorDwellTime)                 {                     flashTotalScore = false;                      // stop recording the state transitions for this trial                     CancelInvoke("RecordFSMState");                      // Re-insert the trial further in the sequence for trying again later                     RepeatTrialAgainLater();                       StateNext(STATE_SETUP);                 }                 break;                         case STATE_REST:                  elapsedRestbreakTime = restbreakTimer.ElapsedSeconds();                  if (elapsedRestbreakTime > restbreakDuration)                 {                     NextScene();                     StateNext(STATE_SETUP);   // move on to the next trial                     break;                 }                 break;               case STATE_GETREADY:                  getReadyTime = getReadyTimer.ElapsedSeconds();                  if (getReadyTime > getReadyDuration)                 {                     NextScene();                     StateNext(STATE_SETUP);   // move on to the next trial                     break;                 }                 break;              case STATE_PAUSE:                 // Note: this state is triggered by exiting fullscreen mode, and can only be escaped from by re-enabling fullscreen mode.                 // pause the countdown timer display and disable the player controls                 pauseClock = true;                  Cursor.lockState = CursorLockMode.Locked;   // disable controller                 break;              case STATE_EXIT:                 // Display the total experiment time and wait for the participant to close the application                 // Note: at the moment this is just to save the correct exiting state transition in the datafile (not incl. in project UniturkDM)                 break;          }     }     // ********************************************************************** //      public void NextScene()     {         // Save the current trial data and move data storage to the next trial         dataController.AddTrial();           dataController.SaveData();     }      // ********************************************************************** //      public void RepeatTrialAgainLater()     {         // Save the current trial data before the participant comes back to this trial later in the trial sequence         dataController.ReinsertErrorTrial();         dataController.SaveData();     }      // ********************************************************************** //      public void NextAttempt()     {         // Save the current trial data before the participant tries the trial again         dataController.AssembleTrialData();         dataController.SaveData();     }      // ********************************************************************** //      public string TrialSetup()     {         // Start the trial with a clean-slate of flags and values         FLAG_trialError = false;         FLAG_trialTimeout = false;         FLAG_fullScreenModeError = false;         whichChoiceMade = "";         choiceMade = false;         correctChoiceMade = false;         displayTimeLeft = false;         scoreUpdated = false;         congratulated = false;         pauseClock = false;         audioFeedbackSounded = false;         flashColourFeedback = false;          trialScore = 0;          // Load in the trial data         currentTrialData = dataController.GetCurrentTrialData();         nextScene = currentTrialData.mapName;          // Load answer to the question         trialAnswer = currentTrialData.trialAnswer;          // Timer variables         maxResponseTime = currentTrialData.maxResponseTime;         preDisplayCueTime = currentTrialData.preDisplayCueTime;         displayCueTime = currentTrialData.displayCueTime;         finalGoalHitPauseTime = currentTrialData.finalGoalHitPauseTime;         pausePriorFeedbackTime = currentTrialData.pausePriorFeedbackTime;         feedbackFlashDuration = currentTrialData.feedbackFlashDuration;         goCueDelay      = currentTrialData.goCueDelay;         minDwellAtReward  = currentTrialData.minDwellAtReward;         displayMessageTime = currentTrialData.displayMessageTime;         errorDwellTime  = currentTrialData.errorDwellTime;         rewardType      = currentTrialData.rewardType;          // Start the next scene/trial         Debug.Log("Upcoming scene: " + nextScene);         SceneManager.LoadScene(nextScene);          string[] menuScenesArray = new string[] { "Exit", "RestBreak", "GetReady"} ;          if (menuScenesArray.Contains(nextScene))         {             return nextScene;   // we don't want to record data and do the FSM transitions during the exit and rest break scenes         }         else         {             return "StartTrial";         }      }      // ********************************************************************** //      public void StartRecording()     {
        // Make sure we're found the player and make sure they cant move (and start recording player and FSM data)
        if (Cursor.lockState == CursorLockMode.None)         {
            // If you're using a movable player controller, use a player controller object to enable and disable, rather than just the cursor
            Cursor.lockState = CursorLockMode.Locked;         }         // Track the state-transitions at the same update frequency as the FPSPlayer (and putting it here should sync them too)         //Player = GameObject.Find("FPSController");         stateTransitions.Clear();                      // restart the state tracker ready for the new trial         stateTransitions.Add("Game State");          RecordFSMState();                              // catch the current state before the update         InvokeRepeating("RecordFSMState", 0f, dataRecordFrequency);     }      // ********************************************************************** //      public void StartExperiment()     {         experimentTimer.Reset();         NextScene();         TrialSetup();           // start the experiment participant menu etc     }      // ********************************************************************** //      public void StartGame()     {         Debug.Log("The game has started now and into the FSM!");         NextScene();         gameStarted = true;             // start the game rolling!         Cursor.lockState = CursorLockMode.Locked;     }      // ********************************************************************** //      public void ContinueToNextMenuScreen()     {         NextScene();         TrialSetup();     }

    // ********************************************************************** //
     public void SubmitChoice(string choice)      {         Debug.Log("Choice submitted: " + choice);          Cursor.lockState = CursorLockMode.Locked;          whichChoiceMade = choice;       // record the choice         choiceMade = true;
    }

    // ********************************************************************** //

    public void CheckFullScreen()     {         // Check if playing in fullscreen mode. If not, give warning until we're back in full screen.         if (!Screen.fullScreen)         {             if(State!=STATE_STARTSCREEN)             {                 // if we're in the middle of the experiment, send them a warning and restart the trial                 FLAG_fullScreenModeError = true;                 displayMessage = "notFullScreenError";                 StateNext(STATE_PAUSE);             }         }         else         {             if (FLAG_fullScreenModeError)  // they had exited fullscreen mode, but now its back to fullscreen :)             {                 StateNext(STATE_ERROR);    // record that this error happened and restart the trial                 FLAG_fullScreenModeError = false;             }         }     }      // ********************************************************************** //     // Note this is obsolete, because Application.Quit() does not work for web applications, only local ones.     public void ExitGame()     {         Application.Quit();  // close the application     }      // ********************************************************************** //      public void StateNext(int state)     {         // Transition the FSM to the next state         if (State != state)         {             Debug.Log("STATE TRANSITION: " + stateText[State] + " -> " + stateText[state] + ": (" + stateTimer.ElapsedSeconds().ToString("F2") + " sec)");             State = state;             stateTimer.Reset();   // start counting how much time we're in this new state         }     }      // ********************************************************************** //      private void RecordFSMState()     {         // add the current stateof the gameplay at this moment to the array         stateTransitions.Add(State.ToString());     }      // ********************************************************************** //      private void UpdateText()     {         // This is used for displaying boring, white text messages to the player, such as warnings          // Display any major errors that require the player to restart the experiment         while (!dataController.writingDataProperly)          {             displayMessage = "dataWritingError";              // Try another attempt at the save function to see if the connection issue resolves             dataController.SaveData();         }         // It's fixed! So restart the trial         if (displayMessage == "dataWritingError")         {             displayMessage = "restartTrialMessage";             NextAttempt();             StateNext(STATE_SETUP);         }          // Display regular game messages to the player         switch (displayMessage)         {             case "noMessage":                 textMessage = "";                 messageTimer.Reset();                 break;              case "timeoutMessage":                 textMessage = "Trial timed out!";                 if (messageTimer.ElapsedSeconds() > displayMessageTime)                 {                     displayMessage = "noMessage"; // reset the message                 }                 break;              case "restartTrialMessage":                 textMessage = "Restarting trial";                 if (messageTimer.ElapsedSeconds() > displayMessageTime)                 {                     displayMessage = "noMessage"; // reset the message                 }                 break;              case "keepSearchingMessage":                 textMessage = "Well done! \n There is one more cheese to find.";                 if (messageTimer.ElapsedSeconds() > displayMessageTime)                 {                     displayMessage = "noMessage"; // reset the message                 }                 break;              case "dataWritingError":                 textMessage = "There was an error sending data to the web server. \n Please check your internet connection. \n If this message does not disappear, please exit.";                 break;              case "notFullScreenError":                 textMessage = "Please return the application to full-screen mode to continue.";                 break;              case "openBoxQuestion":                 textMessage = "Press space-bar to open the gift box";                 break;          }       }      // ********************************************************************** //      public void OpenBox()     {         source.PlayOneShot(openBoxSound, 1F);     }      // ********************************************************************** //      public void OpenBoxQuestion(bool visible)     {         if (displayMessage == "noMessage")    // don't get rid of any other important messages e.g. the data writing error or restarting trial         {             if (visible)             {                 displayMessage = "openBoxQuestion";             }         }         if (!visible)         {             displayMessage = "noMessage";         }     }      // ********************************************************************** //      public void UpdateScore()     {   // Note that these bools are read in the script TotalScoreUpdateScript.cs         if (currentTrialData.mapName != "Practice") // Don't count the practice trials         {             if (!scoreUpdated)  // just do this once per trial             {                 displayTimeLeft = false;   // freeze the visible countdown                  if (State == STATE_ERROR)  // take off 5 points for a mistrial                 {                     trialScore = -5;                 }                 else                       // increase the total score                 {                                             if (correctChoiceMade)                      {
                        trialScore = 10;   // give 10 points for correct answer                     }                     else                      {                         trialScore = -5;   // deduct 5 points for incorrect answer                      }                   }                 totalScore += trialScore;                 scoreUpdated = true;                 flashTotalScore = true;             }         }     }      // ********************************************************************** //      public void DisableRewardByIndex(int index)     {         // ***HRS This has been simplified for generalised version with one reward only.         // Disable whichever of the rewards was just hit. Called from RewardHitScript.cs         switch (index)         {             case 1:                 rewardVisible = false;                 break;             default:                 rewardVisible = false;                 break;         }     }      // ********************************************************************** //      public string GetCurrentMapName()     {         // Return the name of the currently active scene/map (for saving as part of TrialData)         return SceneManager.GetActiveScene().name;     }      // ********************************************************************** //      public int GetCurrentMapIndex()     {         // Return the index of the currently active scene/map (for saving as part of TrialData)         return SceneManager.GetActiveScene().buildIndex;     }      // ********************************************************************** //  }  