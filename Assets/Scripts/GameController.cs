using UnityEngine; using System.Collections; using System.Collections.Generic; using UnityEngine.UI; using UnityEngine.SceneManagement; using System; using System.Runtime.Serialization.Formatters.Binary; using UnityStandardAssets.Characters.FirstPerson; using System.IO; using System.Linq;  public class GameController : MonoBehaviour {
    /// <summary>     /// GameController.cs is a singleton script that controls the game logic/flow within and between scenes.      /// Gameplay has been centralised as much as possible so that all main processes branch from here.      /// This is a simplified, general purpose version for creating different behavioural experiments in Unity.     ///       /// Notes:  - be aware that the script AnswerButtonPoolControl.cs also contains some short but important game logic.      ///         However AnswerButtonPoolControl is instantiated per-scene to link the dynamic generation of buttons to particular areas/panels in each scene.     /// Issues: - cursor locking (and the resetting of the cursor position to the screen centre) using CursorLockMode.Locked     ///           works well in the Unity Editor, but will not work when run in a browser unless triggered by a button press.     ///           This is due to browser security issues and does not seem to have an obvious work-around, so currently when run in webGL the cursor will reappear where it last was.
    ///           - ***HRS one work-around could be to use keyboard arrow/Enter button input for gameplay instead of a mouse.
    ///      /// Author: Hannah Sheahan, sheahan.hannah@gmail.com     /// Date: - 30 Oct 2018      ///       - revised 18 Dec 2018 for simple DM experiments)     ///       - updated 14 Mar 2019 for front-end improvements from FourRooms     ///       - updated 14 Mar 2019 for Summerfield lab away day grandMotherTurker test     /// </summary> 
    // Persistent controllers for data management and gameplay
    private DataController dataController;     public static GameController control;     private FramesPerSecond frameRateMonitor;      // Game data     private GameObject Player;     private GameData currentGameData;     private string filepath;      // Start-of-trial data     private TrialData currentTrialData;     private string currentMapName;     private string currentSceneName;     private string nextScene;      // Within-trial Q/A data that changes with timeframe     private bool choiceSubmitted = false;     public bool choiceRecorded = false;     public bool sliderChoiceMade = false;     public string whichChoiceMade;     public bool correctChoiceMade = false;     public float confidence;     private string trialAnswer;     public string trialQuestion;     public string trialStimulus;     public string[] trialPossibleAnswers;      // Audio clips     public AudioClip choiceMadeSound;     public AudioClip goCueSound;     public AudioClip errorSound;
    public AudioClip correctSound;     public AudioClip fallSound;     public AudioClip openBoxSound;     private AudioSource source;      // Messages to the screen     private string displayMessage = "noMessage";     public string textMessage = "";     public bool displayCue;     public bool interactableObjectVisible;     public int trialScore = 0;     public int totalScore = 0;     public int nextScore;     public bool flashTotalScore = false;     public bool scoreUpdated = false;     public bool pauseClock = false;     public bool congratulated = false;     public bool audioFeedbackSounded = false;     public bool flashColourFeedback = false;      // Timer variables     private Timer experimentTimer;     private Timer stateTimer;     private Timer movementTimer;     private Timer restbreakTimer;     private Timer getReadyTimer;     public  Timer messageTimer;     public float responseTime;     public float totalExperimentTime;     public float currentTickingTrialTime;           // current trial time for measuring RX. Measured from 'go' cue     public bool  displayTimeLeft;      public float maxResponseTime;       private float preDisplayCueTime;     private float goCueDelay;     private float displayCueTime;     private float finalGoalHitPauseTime;     public float displayMessageTime;      public float errorDwellTime;     public float restbreakDuration;     public float elapsedRestbreakTime;     public float getReadyTime;     public float getReadyDuration;     public float pausePriorFeedbackTime;     private float feedbackFlashDuration;      public float dataRecordFrequency;           // NOTE: this frequency is referred to in TrackingScript.cs for player data and here for state data     public float timeRemaining;      private float minFramerate = 30f;           // minimum fps required for decent gameplay on webGL build (fps depends on user's browser and plugins)      // Error flags     public bool FLAG_trialError;     public bool FLAG_trialTimeout;     public bool FLAG_fullScreenModeError;     public bool FLAG_dataWritingError;          // Game-play state machine states     public const int STATE_STARTSCREEN = 0;     public const int STATE_SETUP       = 1;     public const int STATE_STARTTRIAL  = 2;     public const int STATE_CUEAPPEAR   = 3;     public const int STATE_DELAY       = 4;     public const int STATE_GO          = 5;     public const int STATE_MOVING      = 6;     public const int STATE_CHOICEMADE  = 7;     public const int STATE_FINISH      = 8;     public const int STATE_NEXTTRIAL   = 9;     public const int STATE_INTERTRIAL  = 10;     public const int STATE_TIMEOUT     = 11;     public const int STATE_ERROR       = 12;     public const int STATE_FEEDBACK    = 13;     public const int STATE_REST        = 14;     public const int STATE_GETREADY    = 15;     public const int STATE_PAUSE       = 16;     public const int STATE_EXIT        = 17;     public const int STATE_MAX         = 18;      private string[] stateText = new string[] { "StartScreen","Setup","StartTrial","CueAppear","Delay","Go","Moving","ChoiceMade", "Finish","NextTrial","InterTrial","Timeout","Error","Feedback","Rest","GetReady","Pause","Exit","Max" };     public int State;     public int previousState;                                    // Currently unused, but useful for transitioning back to same point in gameplay following an event     public List<string> stateTransitions = new List<string>();   // recorded state transitions      private bool gameStarted = false;      // ********************************************************************** //      void Awake ()           // Awake() executes once before anything else     {         // Make GameController a singleton         if (control == null)   // if control doesn't exist, make it         {             DontDestroyOnLoad(gameObject);             control = this;         }         else if (control != this) // if control does exist, destroy it         {             Destroy(gameObject);         }     }      // ********************************************************************** //      private void Start()     // Start() executes once when object is created     {         dataController = FindObjectOfType<DataController>();    // usually we should be careful with 'Find', but since there is only one DataController should be ok.         source = GetComponent<AudioSource>();         frameRateMonitor = GetComponent<FramesPerSecond>();          // Trial invariant data         filepath = dataController.filePath;          Debug.Log("File path: " + filepath);         dataRecordFrequency = dataController.GetRecordFrequency();         restbreakDuration = dataController.GetRestBreakDuration();         getReadyDuration = dataController.GetGetReadyDuration();          // Initialise the timers         experimentTimer = new Timer();         movementTimer = new Timer();         messageTimer = new Timer();         restbreakTimer = new Timer();         getReadyTimer = new Timer();          // Initialise FSM State         State = STATE_STARTSCREEN;         previousState = STATE_STARTSCREEN;         stateTimer = new Timer();         stateTimer.Reset();         stateTransitions.Clear();          // Ensure cue images are off         displayCue = false;         interactableObjectVisible = false;          StartExperiment();        }      // ********************************************************************** //      private void Update()     // Update() executes once per frame     {         UpdateText();         CheckFullScreen();          if (!pauseClock)         {             currentTickingTrialTime = movementTimer.ElapsedSeconds();         }          switch (State)         {              case STATE_STARTSCREEN:                 // Note: we chill out here in this state until all the starting info pages are done                 if (gameStarted)                 {                     StateNext(STATE_SETUP);                 }                 break;              case STATE_SETUP:                  switch (TrialSetup())                 {                     case "StartTrial":                         // ensure the reward is hidden from sight                         interactableObjectVisible = false;                         StateNext(STATE_STARTTRIAL);                          break;                     case "Menus":                         //   ***HRS to remove: this case should never have to do anything                         break;                      case "GetReady":                         getReadyTimer.Reset();                         StateNext(STATE_GETREADY);                         break;                      case "RestBreak":                         restbreakTimer.Reset();                         StateNext(STATE_REST);                         break;                      case "Exit":                         totalExperimentTime = experimentTimer.ElapsedSeconds();                         EnableCursor(true);                         StateNext(STATE_EXIT);                         break;                  }                 break;              case STATE_STARTTRIAL:                  StartRecording();                      // Wait until the goal/target cue appears                 if (stateTimer.ElapsedSeconds() >= preDisplayCueTime)                 {
                    EnableCursor(false);                      StateNext(STATE_CUEAPPEAR);                 }                 break;               case STATE_CUEAPPEAR:

                // Display the visual cue for displayCueTime seconds before we enable responses                 displayCue = true;                 if (stateTimer.ElapsedSeconds() > displayCueTime)                 {                     //displayCue = false;                     choiceSubmitted = false;                     sliderChoiceMade = false;                     choiceRecorded = false;                     StateNext(STATE_DELAY);                     break;                 }                 break;              case STATE_DELAY:                  // Wait for the go audio cue                 if (stateTimer.ElapsedSeconds() >= goCueDelay)                 {                     source.PlayOneShot(goCueSound, 1F);                     interactableObjectVisible = true;          // Note: not currently used. For making an interactable 3D object appear following the static cue                     StateNext(STATE_GO);                 }                 break;              case STATE_GO:

                // Enable the controller
                EnableCursor(true);                  // Make a 'beep' go sound and start the trial timer                 movementTimer.Reset();                 displayTimeLeft = true;                       // display the trial time countdown                 StateNext(STATE_MOVING);                 break;              case STATE_MOVING:                  // Wait here until a choice is made by the player                 if (movementTimer.ElapsedSeconds() > maxResponseTime) // limit response time                 {                     StateNext(STATE_TIMEOUT);                 }                  if (choiceSubmitted)                 {                     source.PlayOneShot(choiceMadeSound, 1F);                     responseTime = movementTimer.ElapsedSeconds();                     displayTimeLeft = false;                   // freeze the visible countdown                     StateNext(STATE_CHOICEMADE);
                }                 break;              case STATE_CHOICEMADE:

                // its nice to wait a moment or so before providing feedback
                if (stateTimer.ElapsedSeconds() > pausePriorFeedbackTime)                  {                     StateNext(STATE_FEEDBACK);                 }                  break; 

            case STATE_FEEDBACK:

                // display appropriate feedback colour highlight and feedback sound                 if ( !audioFeedbackSounded )                  {
                    /*                     // determine whether the choice was correct or not
                    if (whichChoiceMade == trialAnswer)                     {                         Debug.Log("Choice correct!");                         correctChoiceMade = true;                         source.PlayOneShot(correctSound, 1F);                     }                     else                     {                         Debug.Log("Choice incorrect!");                         correctChoiceMade = false;                         source.PlayOneShot(errorSound, 1F);                     }                     */

                    // don't give the participant feedback on whether their choice was correct or not
                    Debug.Log("An answer was selected.");
                     // ... but record in the datafile if the answer was correct or not                     if (whichChoiceMade == trialAnswer)                     {                         correctChoiceMade = true;                     }                     else                     {                         correctChoiceMade = false;                     }

                    flashColourFeedback = true;              // make the button glow to give colour feedback                     audioFeedbackSounded = true;                 }

                // update the total score and flash feedback on the screen
                if (stateTimer.ElapsedSeconds() > feedbackFlashDuration)
                {                     flashColourFeedback = false;            // turn the colour button feedback off
                    displayCue = false;                     // get rid of the question text                     UpdateScore();                          
                }                  // After some time, finish the trial and move on
                if (stateTimer.ElapsedSeconds() > finalGoalHitPauseTime)
                {
                    flashTotalScore = false;
                    StateNext(STATE_FINISH);
                }

                break;              case STATE_FINISH:                  // stop recording the state transitions for this trial                 CancelInvoke("RecordFSMState");                  // end the trial, save the data                 NextScene();                 StateNext(STATE_SETUP);                 break;              case STATE_TIMEOUT:                  // Player didn't respond quickly enough                 FLAG_trialTimeout = true;                 Debug.Log("Trial timed out: (after " + movementTimer.ElapsedSeconds() + " sec)");                 StateNext(STATE_ERROR);                 break;              case STATE_ERROR:                  // turn off the question text                 displayCue = false;                  // Handle error trials by recording data as another attempt at the same trial number                 if (FLAG_trialError == false)                 {                     source.PlayOneShot(errorSound, 1F);                     displayMessage = "restartTrialMessage";                     UpdateScore();   // take -20 points off total score                 }                 FLAG_trialError = true;                  responseTime = movementTimer.ElapsedSeconds();                  // Wait a little while in the error state to display the error message                 if (stateTimer.ElapsedSeconds() > errorDwellTime)                 {                     flashTotalScore = false;                      // stop recording the state transitions for this trial                     CancelInvoke("RecordFSMState");                      // Re-insert the trial further up in the sequence for trying again later                     RepeatTrialAgainLater();                       StateNext(STATE_SETUP);                                      // reset the error flags so the trial can correctly restart                     FLAG_dataWritingError = false;                     FLAG_fullScreenModeError = false;                                      }                 break;                         case STATE_REST:                  // Take a rest break                 elapsedRestbreakTime = restbreakTimer.ElapsedSeconds();                  if (elapsedRestbreakTime > restbreakDuration)                 {                     NextScene();                     StateNext(STATE_SETUP);   // move on to the next trial                     break;                 }                 break;               case STATE_GETREADY:                  // Wait for the main experiment to start while watching a pretty countdown wheel                 getReadyTime = getReadyTimer.ElapsedSeconds();                  if (getReadyTime > getReadyDuration)                 {                     NextScene();                     StateNext(STATE_SETUP);   // move on to the next trial                     break;                 }                 break;              case STATE_PAUSE:                 // Note: this state is triggered by exiting fullscreen mode, and can only be escaped from by re-enabling fullscreen mode.                 // pause the countdown timer display and disable the player controls                 pauseClock = true;
                EnableCursor(false);         // disable controller                 break;              case STATE_EXIT:                 // Display the total experiment time and wait for the participant to close the application                 // Note: at the moment this is just to save the correct exiting state transition in the datafile (not incl. in project UniturkDM)                 break;          }     }     // ********************************************************************** //      public void NextScene()     {         // Save the current trial data and move data storage to the next trial         dataController.AddTrial();           dataController.SaveData();     }      // ********************************************************************** //      public void RepeatTrialAgainLater()     {         // Save the current trial data before the participant comes back to this trial later in the trial sequence         dataController.ReinsertErrorTrial();         dataController.SaveData();     }      // ********************************************************************** //      public void NextAttempt()     {         // Save the current trial data before the participant tries the trial again (immediate reattempt)         dataController.AssembleTrialData();         dataController.SaveData();     }      // ********************************************************************** //      public string TrialSetup()     {         // Start the trial with a clean-slate of flags and values         FLAG_trialError = false;         FLAG_trialTimeout = false;         FLAG_dataWritingError = false;         FLAG_fullScreenModeError = false;         whichChoiceMade = "";         confidence = 0.5f;         choiceSubmitted = false;         choiceRecorded = false;         sliderChoiceMade = false;         correctChoiceMade = false;         displayTimeLeft = false;         scoreUpdated = false;         congratulated = false;         pauseClock = false;         audioFeedbackSounded = false;         flashColourFeedback = false;
        displayCue = false;         trialScore = 0;          // Load in the trial data         currentTrialData = dataController.GetCurrentTrialData();         nextScene = currentTrialData.mapName;          // Load question and answers to the question         trialQuestion = currentTrialData.trialQuestion;         trialAnswer = currentTrialData.trialAnswer;         trialStimulus = currentTrialData.trialStimulus;         trialPossibleAnswers = currentTrialData.trialPossibleAnswers;          // Timer variables         maxResponseTime = currentTrialData.maxResponseTime;         preDisplayCueTime = currentTrialData.preDisplayCueTime;         displayCueTime = currentTrialData.displayCueTime;         finalGoalHitPauseTime = currentTrialData.finalGoalHitPauseTime;         pausePriorFeedbackTime = currentTrialData.pausePriorFeedbackTime;         feedbackFlashDuration = currentTrialData.feedbackFlashDuration;         goCueDelay      = currentTrialData.goCueDelay;         displayMessageTime = currentTrialData.displayMessageTime;         errorDwellTime  = currentTrialData.errorDwellTime; 
        // Start the next scene/trial
        Debug.Log("Upcoming scene: " + nextScene);         SceneManager.LoadScene(nextScene);          string[] menuScenesArray = new string[] { "Exit", "RestBreak", "GetReady"} ;          if (menuScenesArray.Contains(nextScene))         {             return nextScene;   // we don't want to record data and do the FSM transitions during the exit and rest break scenes         }         else         {             return "StartTrial";         }      }      // ********************************************************************** //      public void StartRecording()     {
        // Make sure we've found the player and make sure they cant move (and start FSM data)
        if (Cursor.lockState == CursorLockMode.None)         {
            EnableCursor(false);         }         // Track the state-transitions         stateTransitions.Clear();                      // restarts the state tracker ready for the new trial         stateTransitions.Add("Game State");          RecordFSMState();                              // catch the current state before the update         InvokeRepeating("RecordFSMState", 0f, dataRecordFrequency);     }      // ********************************************************************** //      public void StartExperiment()     {         experimentTimer.Reset();         NextScene();         TrialSetup();           // start the experiment participant menu etc
    }      // ********************************************************************** //      public void StartGame()     {         Debug.Log("The game has started now and into the FSM!");         NextScene();         gameStarted = true;             // start the game rolling!         EnableCursor(false);     }      // ********************************************************************** //      public void ContinueToNextMenuScreen()     {         NextScene();         TrialSetup();     
    }
     // ********************************************************************** //

    public void SubmitChoice()      {         Debug.Log("Choice submitted.");         EnableCursor(false);
        choiceSubmitted = true;
    }
    // ********************************************************************** //

    public void RecordChoice(string choice)
    {         Debug.Log("Choice selected: " + choice);         whichChoiceMade = choice;       // record the choice         choiceRecorded = true;     }     // ********************************************************************** //

    public void RecordSliderValue(float value)
    {         Debug.Log("Slider value changed.");         confidence = value;       // record the choice         sliderChoiceMade = true;     } 
    // ********************************************************************** //
     public void EnableCursor(bool enable)      {         // Note that cursor locking (and respective resetting of cursor to the screen centre) using CursorLockMode.Locked         // works well in the Unity Editor but will not work when run in a browser, unless triggered by a button press.         // This is a browser security issue and does not seem to have an obvious work-around, so the cursor will reappear where it last was.         // Note: ***HRS one work-around could be to use keyboard arrow/Enter button input for gameplay instead of a mouse. 
        bool isLocked;         if (enable)          {             Cursor.lockState = CursorLockMode.None;             Cursor.visible = true;
            isLocked = (Cursor.lockState == CursorLockMode.Locked);             //Debug.Log("Cursor should be unlocked. Lock state is: " + isLocked);
        }         else          {
            Cursor.lockState = CursorLockMode.Locked;             Cursor.visible = false;             isLocked = (Cursor.lockState == CursorLockMode.Locked);             //Debug.Log("Cursor should be locked. Lock state is: " + isLocked);
        }
    }

    // ********************************************************************** //

    public void CheckFramerate()     {
        // Check if the game framerate is sufficiently high. If not, give warning telling them to open in a different browser with fewer plugins or quit.
        if (frameRateMonitor.Framerate < minFramerate)         {             if (State != STATE_STARTSCREEN)             {
                // prioritise the writing error messages 
                if ((displayMessage != "dataWritingError") & (displayMessage != "notFullScreenError"))                 {
                    // if we're in the middle of the experiment, send them a warning and pause the experiment
                    displayMessage = "framerateError";                     Debug.Log("ERROR: Frame rate of " + frameRateMonitor.Framerate.ToString() + " fps is too low for gameplay.");                     StateNext(STATE_PAUSE);                 }             }         }     }      // ********************************************************************** //      public void CheckWritingProperly()     {         // Check if data is writing to file correctly.         if (!dataController.writingDataProperly)         {             FLAG_dataWritingError = true;             displayMessage = "dataWritingError";              if (State != STATE_PAUSE)              {                  Debug.Log("There was a data writing error. Trial will save and restart once connection is re-established.");             }              // Disable the player controls (can get missed if only triggered from STATE_PAUSE when a trial finishes)             StateNext(STATE_PAUSE);              // Every little while, try another attempt at saving to see if the connection issue resolves (allows error message to be seen for sufficient length of time too)             if (messageTimer.ElapsedSeconds() > displayMessageTime)             {                 dataController.SaveData();                 messageTimer.Reset();             }         }         else         {             if (FLAG_dataWritingError)  // they had a writing error, but now its fixed :)             {                 // Writing connection is fixed! So restart the trial                 displayMessage = "restartTrialMessage";                 StateNext(STATE_ERROR);    // record that this error happened and restart the trial (trial will be repeated later)             }         }     }      // ********************************************************************** //

    public void CheckFullScreen()     {         // Check if playing in fullscreen mode. If not, give warning until we're back in full screen.         if (!Screen.fullScreen)         {             if(State!=STATE_STARTSCREEN)             {                 // if we're in the middle of the experiment, send them a warning and restart the trial                 FLAG_fullScreenModeError = true;                 displayMessage = "notFullScreenError";                 StateNext(STATE_PAUSE);             }         }         else         {             if (FLAG_fullScreenModeError)  // they had exited fullscreen mode, but now its back to fullscreen :)             {                 StateNext(STATE_ERROR);    // record that this error happened and restart the trial             }         }     }      // ********************************************************************** //     // Note this is obsolete, because Application.Quit() does not work for web applications, only local ones.     public void ExitGame()     {         Application.Quit();  // close the application     }      // ********************************************************************** //      public void StateNext(int state)     {         // Transition the FSM to the next state         if (State != state)         {             Debug.Log("STATE TRANSITION: " + stateText[State] + " -> " + stateText[state] + ": (" + stateTimer.ElapsedSeconds().ToString("F2") + " sec)");             State = state;             stateTimer.Reset();   // start counting how long we're in this new state for         }     }      // ********************************************************************** //      private void RecordFSMState()     {         // add the current state of the gameplay at this moment to the array         stateTransitions.Add(State.ToString());     }      // ********************************************************************** //      private void UpdateText()     {         // This is used for displaying boring, white text messages to the player, such as warnings          // Display regular game messages to the player         switch (displayMessage)         {             case "noMessage":                 textMessage = "";                 messageTimer.Reset();                 break;              case "restartTrialMessage":                 textMessage = "Restarting trial";                 if (messageTimer.ElapsedSeconds() > displayMessageTime)                 {                     displayMessage = "noMessage"; // reset the message                 }                 break;


            case "dataWritingError":                 textMessage = "There was an error sending data to the web server. \n Please check your internet connection. \n If this message does not disappear, please exit.";                 break;              case "framerateError":                 textMessage = "The browser-dependent frame rate is insufficient for this HIT. \n Please exit, or try using Chrome/Firefox with no plugins.";                 break;              case "notFullScreenError":                 textMessage = "Please return the application to full-screen mode to continue.";                 break;
             case "openBoxQuestion":                 textMessage = "Press space-bar to open the gift box";                 break;          }       }      // ********************************************************************** //      public void UpdateScore()     {            // Note that these bools are read in the script TotalScoreUpdateScript.cs          if (currentTrialData.mapName != "Practice")         {             if (!scoreUpdated)              // update once per trial             {                 displayTimeLeft = false;    // freeze the visible countdown                  if (State == STATE_ERROR)                    {                     trialScore = 0;       // dont deduct anything for a misstrial
                }                 else                                        {                                             // who cares if the answer was correct or not, give them some points for answering on time!                     trialScore = 10;   // give 10 points                 }                 totalScore += trialScore;                 scoreUpdated = true;                 flashTotalScore = true;             }         }     } 
    // ********************************************************************** //

    public string GetCurrentMapName()     {         return SceneManager.GetActiveScene().name;     }      // ********************************************************************** //      public int GetCurrentMapIndex()     {         return SceneManager.GetActiveScene().buildIndex;     }      // ********************************************************************** //  }